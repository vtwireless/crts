<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8"/>

    <style type="text/css">
body {
    background-color:#C0D0E0;
}

canvas.clock {
    background-color: #B6ECDC;
    width: 100%;
    height: 100%;
    padding: 0px;
    margin: 0px;
}


    </style>
    <link rel='stylesheet' href='../webDesktop/webDesktop.css'></link>
    <link rel='stylesheet' href='scope.css'></link>
    <script src='../webDesktop/webDesktop.js'></script>
    <script src='../webDesktop/clock.js'></script>
    <script src=scope.js></script>
    <script>


onload = function() {


    function saw(x_in) {

        const PI_D2 = Math.PI/2.0;
        const T_PI = 2.0 * Math.PI;

        // This is a symmetric saw tooth function with amplitude 1 and
        // period 2 Pi, and 

        // First find a corresponding x that is near zero and differs
        // by a multiple of 2 pi.
        //if(x_in < 0.0) {}
        let y; 
        let x = x_in % T_PI;
        if(x < 0.0) x = -x;

        if(x <= Math.PI)
            y = 1.0 - x / PI_D2;
        else
            y = x / PI_D2 - 3.0;

        return y;
    }


    var clock = new Clock;
    new WDApp('Clock', clock.getElement());
    clock.run();

    // standing wave parameters
    const numPoints = 200; // samples per frame = x,y array size.
    const period = 10.0; // period in seconds
    const nNodes = 4.5; // number of nodes in the sting standing wave
    const A = 1.5; // Amplitude of anti-node.
    const sleepTime = 30; // sleep period in milliseconds
    const timeFunc = saw;
    
    // Derived constants
    const k = Math.PI * nNodes/numPoints; // like wave number
    const omega = 2 * Math.PI/period; // angular frequency

    const cos = Math.cos;
    const sin = Math.sin;

    var scope = new Scope;

    new WDApp('String', scope.getElement());

    var x = [], y = [];
    var t = period/4;

    function run() {

        for(let i=0; i<numPoints; ++i) {

            // Switching x and y just to mess with my head.  No
            // really, we just are testing the auto-scaling of
            // xMax because that was the first auto-scaling boundary
            // that was implemented.

            y[i] = i;

            x[i] = A * timeFunc(omega*t) * sin(k*i);
        }

        scope.draw(x, y);

        // Advance time t, and we don't care if it is not
        // accurate or precise; this is just a test.
        t += sleepTime/1000.0;
        if(t > period)
            // Cheep way to keep time, t, for getting too large.
            // And we don't care if this is adds progressive rounding
            // errors compared to using a counter.
            t -= period;
    }

    run();

    setInterval(run, sleepTime/* in milliseconds = 1/1000 */);
};

    </script>


    <title>CRTS</title>
</head>
<body>

</body>
</html>
