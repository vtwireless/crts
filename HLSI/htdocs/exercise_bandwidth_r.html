<!DOCTYPE html>
<html lang="en-US">
<head>
  <title>Bandwidth; Real</title>
  <meta charset="UTF-8"/>
  <script src='/load.js'></script>
  <link rel="stylesheet" type="text/css" media="all" href="base.css">
</head>

<body>

  <h2>Exercise - Bandwidth; Real Signal</h2>
  <p><a href="index.html">[exercises]</a></p>
  <p>
    <label for="bandwidth">Bandwidth</label>
    <input class="width-4" type="range" min="0.1" max="0.9" value="0.2" id="bandwidth" step="0.001"
        oninput="update_bw(parseFloat(value))">
    <output for="bandwidth" id="bw"></output>
  </p>
</body>

<!-- Load in the javascript libraries -->
<script src="d3.v5.min.js"></script>
<script src="support.js"></script>
<script>

// 2. Use the margin convention practice
var margin = {top: 50, right: 50, bottom: 50, left: 50}
  , width  = 920 - margin.left - margin.right  // Use the window's width
  , height = 320 - margin.top - margin.bottom; // Use the window's height

// The number of datapoints
var fs = 4e6, f0 = 915.5e6;     // sample rate, center frequency
var fc = 0;
var bw = 0.25; // filter bandwidth
var bins = 200;

// determine time and frequency scale/units
var [scale_freq,units_freq] = scale_units(f0+fs/2,0.1); // freq scale

// 5. X scale will use the index of our data
var fScale = d3.scaleLinear().domain([(f0-0.5*fs)*scale_freq, (f0+0.5*fs)*scale_freq]).range([0, width]);

// 6. Y scale will use the randomly generate number
var vScale = d3.scaleLinear().domain([ -1.1,  1.1]).range([height, 0]);
var pScale = d3.scaleLinear().domain([-90, -20]).range([height, 0]);

// 7. d3's line generator
    //.curve(d3.curveMonotoneX) // apply smoothing to the line (comment out to remove smoothing)
var linef = d3.line()
    .x(function(d, i) { return fScale((f0+(i/bins-0.5)*fs)*scale_freq); })  // map frequency
    .y(function(d)    { return pScale(d.y);        }); // map PSD

// 8. An array of objects of length N. Each object has key -> value pair, the key being "y" and the value is a random number
var datai = {};
var dataq = {};
var dataf = d3.range(0,bins-1).map(function(f) { return {"y": 0 } })

// create SVG objects
var svgf = svg_create(margin, width, height, fScale, pScale);

// add labels
svg_add_labels(svgf, margin, width, height, "Frequency ("+units_freq+"Hz)", "Power Spectra Density (dB)");

// clip paths
svgf.append("clipPath").attr("id","clipf").append("rect").attr("width",width).attr("height",height);

// 9. Append the path, bind the data, and call the line generator
var pathf = svgf.append("path")
    .attr("clip-path","url(#clipf)")
    .datum(dataf)
    .attr("class", "stroke-med no-fill stroke-red")
    .attr("d", linef);


var setBandwidthCB = false;


// example bw = 914.16  for 914.16 MHz
//
function update_slider(bandwidth) {

    // This should update the slider frequency from the web.
    //
    bw = bandwidth/(fs*scale_freq);
    //
    document.querySelector('#bw').value = d3.format(".2f")(bw*fs*scale_freq) + " " + units_freq + "Hz";
    document.querySelector('#bandwidth').value = bw;

    console.log("bw=" + bw);
}


update_bw();

function update_bw(band) {
    if (band!=null) { bw = band; }

    document.querySelector('#bw').value = d3.format(".2f")(bw*fs*scale_freq) + " " + units_freq + "Hz";
    //document.querySelector('#bandwidth').value = bw;

    if(setBandwidthCB) 
        // Send freq to the web server.
        setBandwidthCB(bw*fs*scale_freq);

    console.log("bw=" + bw);
}



function update_plot(y) {

    // generate power spectral density

    dataf = d3.range(0,bins-1).map(function(i) { 
        return {"y": 20*Math.log10(y[i]) }
    });
    pathf.datum(dataf).attr("d", linef);
}


// TODO: This argument parsing crap needs to be fixed, on the server.
//
function spec_updateCB(xxx) {

    var args = [].slice.call(arguments);
    // This is f*cked up.
    args = args[0];

    var id = args.shift(),
        cFreq = args.shift(),
        bandwidth = args.shift(),
        updatePeriod = args.shift();

    var y = args.shift();

    update_plot(y);
}


require('/spectrum/feed.js');

onload = function() {

    createSession(function(io) {

        io.Emit('getLauncherPrograms');
        io.On('receiveLauncherPrograms', function(programs) {
            // We know what the programs are so here we go:
            io.Emit('launch', '/spectrumFeed',
                '--bins ' + bins +
                ' --freq ' + f0/1.0e6, { runOne: true });
            io.Emit('launch', '/tx', '', { runOne: true });
        });

        io.On('getParameter', function(programName,
            controlName, parameter, value) {
            if(controlName === 'tx' && parameter === 'rate') {
                console.log("got rate=" + value * 1.0e-6);
                update_slider(value * 1.0e-6);
            }
        });


        io.On('addController', function(programName, set, get, image) {

           console.log('Got On("addController",) program="' +
                programName + '"' +
                '\n    set=' + JSON.stringify(set) +
                '\n    get=' + JSON.stringify(get) +
                '\n  image=' + image);

            if(set['tx'] !== undefined &&
                    set['tx']['rate'] !== undefined) {

                setBandwidthCB = function(bw) {
                    let rate = 1.0e6 * bw;
                    console.log("Setting bw=" + bw + " => rate=" + rate);
                    io.Emit('setParameter', programName,'tx','rate',rate);
                }
            }
        });


        var spc = spectrumFeeds(io, {
            // newSpectrum callback
            newSpectrum: function(id) {  
                console.log('newSpectrum:' + [...arguments]);
                console.log("SUBSCRIBING TO: " + id);
                spc.subscribe(id, spec_updateCB);
            },

            spectrumEnd: function() {
                console.log('spectrumEnd:' + [...arguments]);
            }
        });


    }, { addAdminPanel: false, showHeader: false, loadCRTScss: false});
};

</script>
